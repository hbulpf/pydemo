# Python总结与复习

> ```
> #!/usr/bin/env python
> # -*- coding: utf-8 -*-
> ```

## 基本语法

### 数据类型

Python的数据类型有 

1. 整数
2. 浮点数
3. 字符串 `'str1'` / `"str2"` / `''' str3'''` / `"""str4"""`
4. 布尔值: True / False
5. 空值: None , 是一个特殊的空值。 
6. 常量: 通常用全部大写的变量名表示常量, 只是一个习惯,值可以被改变

变量

```python
a = 5 <= 3 or True
a = 10 % 3 + 10 // 3  #地板除得到整数
a = 10 % 3 + 10 / 3 #除法得到浮点数
a = 2**3 #计算乘方
a = 'ABC' 
b = a
a = 'XYZ' #输出b: ABC, a和b都是地址
PI = 3.1415
```



### 输入/输出

#### 从键盘输入
```python
name = input('Please enter your name: ')
print(name)
```

#### 输出字符串

##### 字节

```python
#b表示bytes
print('ABC'.encode('ascii'))
print('ABC'.encode('utf-8'))
print('中文'.encode('utf-8'))
a = b'\xe4\xb8\xad\xff'.decode('utf-8',errors='ignore')
print(a)
print(len(a),len(b'\xe4\xb8\xad'),len('中'.encode('utf-8')))
print('中文测试正常')
```

##### 不转义

`r` 表示内部字符默认不转义
```python
print(r'seek\t\n\\')
print('''line1
line2
line3''')
print(r'''line1
line2
line3''')
```

##### 字符串格式化

```python
#格式化方式1
print('age: %d, name: %s, stunum: %04d, ave_score:%.2f' % (25, '然然', 32, 73.1415926))

#格式化方式2: format()
print('{0}成绩提升了{1:.2f}%'.format('童童', 5.2316))
print('my name is {0}, I am {1} years old. Please call me {0}'.format('陈明',12))

#格式化方式3: f-string
r = 2.5
s = 3.14 * r ** 2
print(f'The area of a circle with radius {r} is {s:.2f}')
```

| 占位符 | 替换内容     |
| :----- | :----------- |
| %d     | 整数         |
| %f     | 浮点数       |
| %s     | 字符串       |
| %x     | 十六进制整数 |

##### 字符串其他操作

替换字符

```python
a = 'abc'
b = a.replace('a', 'A')
```



###  条件与循环

条件语句
```python
height = float(input('height: '))
weight = float(input('weight: '))
bmi = weight / height**2
if bmi < 18.5:
    print('过轻')
elif bmi >= 18.5 and bmi < 25:
    print('正常')
elif bmi >= 25 and bmi < 28:
    print('过重')
else:
    print('肥胖')

if age >= 18:
    #什么都不做
    pass
```

for循环
```python
names = ['Michael', 'Bob', 'Tracy']
for name in names:
    print(name)
    
sum = 0
for x in range(101):
    sum = sum + x
if sum == 5050:
    print('Gauss is correct.')
else:
    print('Gauss is wrong.')
d = {'a': 1, 'b': 2, 'c': 3}   
for key in d:
     print(key)
```

> range() 函数左闭右开

while循环

```python
n = 201
pow = 1
while n > 0:
	n = n - 1
	if n % 5 == 0:
		continue
	pow = pow * n
print(pow)
```

### 字典/集合/列表/元组

dictionary 字典，对应于其他语言的map结构
```python
#创建dic
ad = {'mar': 13, (1,2):55,'wat': 67} 

#判断key是否存在
'mar' in ad
#取值
ad['hap'] #不存在抛异常
ad.get('mar') #不存在返回None
ad.get('mar',-1) #不存在返回指定值-1

#增加key
ad['hap'] = 23 
#删除key
ad.pop('mar')
print(ad)
```

set 集合
```python
s = set([2,2,3,(1,2),5]) #要创建一个set，需要提供一个list作为输入集合
s.add(4) #添加元素
s.remove(4) #删除元素
se = set([5,2,(2,3)])
print(se & s) #set做交集
print(se | s) #set做并集

```

list 列表
```python
roommate = ['suhong','ziheng','siyuan'] #创建list
len(roommate) #获取list中元素个数
print(roommate[2]) #取list中元素
print(roommate[-1]) #取list中元素
roommate.append('xinran') #追加元素
roommate.insert(1,['panpan','xinran']) #指定位置添加元素
roommate.pop() #删除末尾元素
roommate.pop(i) #删除索引i处的元素

roommate.sort() #对list进行排序

```

tuple 元组,不可变
```python
she = ('suhong',) #创建tuple
she1 = ('suhong') #这不是创建tuple
she2 = () #创建空tuple
roommate = ('suhong', 'siyuan', ['panpan', 'ziheng'])
roommate[2][1] = 'bianbian'
print(roommate)
print(len(roommate))
```

## 函数

> [python内置函数列表](https://docs.python.org/3/library/functions.html)

对函数的理解: 函数名其实就是指向一个函数对象的引用，完全可以把函数名赋给一个变量，相当于给这个函数起了一个“别名”：

```python
a = abs # 变量a指向abs函数
a(-1) # 所以也可以通过a调用abs函数
```

### 定义函数

```python
#定义一个函数
def my_abs(x):
    if not isinstance(x, (int, float)):
        raise TypeError('bad operand type')
    if x >= 0:
        return x
    else:
        return -x

#定义空函数
def nop():
    pass     
    
#定义函数返回多个值    
def move(x, y, step, angle=0):
    nx = x + step * math.cos(angle)
    ny = y - step * math.sin(angle)
    return nx, ny   
 x, y = move(100, 100, 60, math.pi / 6)    #返回多值实际上是返回tuple 
```

### 函数参数

```python
def move(x, y, step, angle=0):
```

1. 位置参数 :  x,y,step叫做位置参数。

2. 默认参数 : angle=0 叫默认参数。**定义默认参数要牢记一点：默认参数必须指向不变对象！**

   ```python
   def add_end(L=[]): #这种定义指向了可变对象,错误
   def add_end(L=None): #这种定义执行不变对象，正确
   ```

3. 可变参数: 传入一列值或一个list,tuple

   ```python
   def calc(*numbers):
       sum = 0
       for n in numbers:
           sum = sum + n * n
       return sum
   calc(1, 2) 
   
   nums = [1, 2, 3]
   calc(*nums) #在list或tuple前面加一个*号,表示list的所有元素作为可变参数传进去
   ```

   可变参数在函数调用时自动组装为一个tuple

4. 关键字参数

   ```python
   def person(name, age, **kw):
       print('name:', name, 'age:', age, 'other:', kw)
   
   person('Michael', 30)    
   person('Bob', 35, city='Beijing')
   extra = {'city': 'Beijing', 'job': 'Engineer'}
   person('Jack', 24, **extra)
   ```

   关键字参数在函数内部自动组装为一个dic

5. 命名关键字参数

   ```python
   def person(name, age, *, city, job):
       print(name, age, city, job)
   def man(name, age, *, city='Beijing', job):
       print(name, age, city, job)    
   
   #函数定义中已经有了一个可变参数，后面跟着的命名关键字参数就不再需要一个特殊分隔符*了
   def person(name, age, *args, city, job):
       print(name, age, args, city, job)    
   ```

   如果没有可变参数，就必须加一个`*`作为特殊分隔符。如果缺少`*`

其中默认参数、可变参数、关键字参数都可传可不传；位置参数和命名关键字参数必须传入。

参数定义的顺序必须是：位置参数、默认参数、可变参数、命名关键字参数和关键字参数。

> 对于任意函数，都可以通过类似`func(*args, **kw)`的形式调用它，无论它的参数是如何定义的。使用参考[廖雪峰博客函数的参数](https://www.liaoxuefeng.com/wiki/1016959663602400/1017261630425888)

### 递归函数

```python
def fact(n):
    if n==1:
        return 1
    return n * fact(n - 1)
```

## 高级特性

### 切片

```python
L = ['Michael', 'Sarah', 'Tracy', 'Bob', 'Jack']
L[0:3] #取前3个元素,等同于 L[:3]
L[-2:] #从倒数第2个元素开始，取到 L[len-2],L[len-1]
L[-3:-1] #从倒数第2个元素开始,到倒数第1个元素，取到 L[len-3],L[len-2]
L[-1:-3:-1] #从最后一个元素开始，倒数取，取到 L[len-1],L[len-2]，等同于L[:-3:-1] 
```

tuple也是一种list，唯一区别是tuple不可变

```python
(0, 1, 2, 3, 4, 5)[:3]
```

字符串`'xxx'`也可以看成是一种list

```python
'ABCDEFG'[::2]
```

> Python没有针对字符串的substring截取函数，只需要切片一个操作就可以完成

### 迭代

```python
d = {'a': 1, 'b': 2, 'c': 3}
for key in d:
    print(key)
for value in d.values()
for k, v in d.items()
```

只要作用于一个可迭代对象，`for`循环就可以正常运行。判断可迭代对象

```python
from collections.abc import Iterable
isinstance('abc', Iterable)
```

对`list`实现循环下标

```python
for i, value in enumerate(['A', 'B', 'C']):
    print(i, value)
```

`for` 循环可以同时引用多个变量

```python
for x, y in [(1, 1), (2, 4), (3, 9)]:
    print(x, y)
```

### 列表生成式

未来代替繁琐的for循环

```python
[x * x for x in range(1, 11)]
[x * x for x in range(1, 11) if x % 2 == 0]
[m + n for m in 'ABC' for n in 'XYZ']
d = {'x': 'A', 'y': 'B', 'z': 'C' }
[k + '=' + v for k, v in d.items()]

L = ['Hello', 'World', 'IBM', 'Apple']
[s.lower() for s in L]
```

常用例子: 列出当前目录下的所有文件和目录名

```python
import os
[d for d in os.listdir('.')]
```

在`for`后面的`if`是一个筛选条件，不能带`else`.`for`前面的部分是一个表达式，它必须根据`x`计算出一个结果，必须带 else

```python
[x if x % 2 == 0 else -x for x in range(1, 11)]
```

### 生成器

Python中，这种一边循环一边计算的机制，称为生成器：generator。

创建生成器

```python
L = [x * x for x in range(10)] #这是1个list
g = (x * x for x in range(10)) #这是1个生成器
```

通过`next()`函数获得generator

```python
next(g)
```

generator保存的是算法，每次调用`next(g)`，就计算出`g`的下一个元素的值，直到计算到最后一个元素，没有更多的元素时，抛出`StopIteration`的错误。

实际上最常用到for取生成器的元素

```python
g = (x * x for x in range(10))
for n in g:
    print(n)
```

经常将函数作为生成器

```python
def fib(max):
    n, a, b = 0, 0, 1
    while n < max:
        yield b
        a, b = b, a + b
        n = n + 1
    return 'done'
>>> f = fib(6)
>>> f
<generator object fib at 0x104feaaa0>  
#取fib的值
while True:
    try:
        x = next(f)
        print('f:', x)
    except StopIteration as e:
        print('Generator return value:', e.value)
        break
```

`fib`函数是一个生成器。

> 如果一个函数定义中包含`yield`关键字，那么这个函数就不再是一个普通函数，而是一个generator

generator和函数的执行流程不一样。函数是顺序执行，遇到`return`语句或者最后一行函数语句就返回。而变成generator的函数，在每次调用`next()`的时候执行，遇到`yield`语句返回，再次执行时从上次返回的`yield`语句处继续执行。即 **普通函数调用直接返回结果；generator函数的“调用”实际返回一个generator对象**

### 迭代器

凡是可作用于`for`循环的对象都是`Iterable`类型；

凡是可作用于`next()`函数的对象都是`Iterator`类型，它们表示一个惰性计算的序列；

集合数据类型如`list`、`dict`、`str`等是`Iterable`但不是`Iterator`，不过可以通过`iter()`函数获得一个`Iterator`对象。详细参考[廖雪峰博客迭代器](https://www.liaoxuefeng.com/wiki/1016959663602400/1017323698112640)

## 函数式编程

### 高阶函数

高阶函数: 一个函数就可以接收另一个函数作为参数.

```python
def add(x, y, f):
    return f(x) + f(y)

print(add(-5, 6, abs))
```

#### map/reduce

`map()`函数接收两个参数，一个是函数，一个是`Iterable`，`map`将传入的函数依次作用到序列的每个元素，并把结果作为新的`Iterator`返回。

```python
def f(x):
    return x * x
r = map(f, [1, 2, 3, 4, 5, 6, 7, 8, 9])
list(r)
```

list() 函数将迭代器转换为list。

`reduce`把结果和序列的下一个元素做累积计算。效果等价于下面

```python
reduce(f, [x1, x2, x3, x4]) = f(f(f(x1, x2), x3), x4)
```

```python
from functools import reduce
def fn(x, y):
    return x * 10 + y
reduce(fn, [1, 3, 5, 7, 9])
```

一个例子: `str`转换为`int`的函数:

```python
from functools import reduce

DIGITS = {'0': 0, '1': 1, '2': 2, '3': 3, '4': 4, '5': 5, '6': 6, '7': 7, '8': 8, '9': 9}

def char2num(s):
    return DIGITS[s]

def str2int(s):
    return reduce(lambda x, y: x * 10 + y, map(char2num, s))
```

#### filter

`filter()`把传入的函数依次作用于每个元素，然后根据返回值是`True`还是`False`决定保留还是丢弃该元素。

```python
def is_odd(n):
    return n % 2 == 1

list(filter(is_odd, [1, 2, 4, 5, 6, 9, 10, 15]))
```

#### sorted

Python内置的`sorted()`函数就可以对list进行排序

```python
sorted([36, 5, -12, 9, -21])
```

`sorted()`函数是一个高阶函数,接收一个`key`函数来实现自定义的排序

```python
sorted([36, 5, -12, 9, -21], key=abs) #结果为[5, 9, -12, -21, 36]
sorted(['bob', 'about', 'Zoo', 'Credit'], key=str.lower) #忽略大小写的排序
sorted(['bob', 'about', 'Zoo', 'Credit'], key=str.lower, reverse=True) #逆序排序
```

### 返回函数

不需要立刻计算，而是在后面的代码中，根据需要再计算。

```python
def lazy_sum(*args):
    def sum():
        ax = 0
        for n in args:
            ax = ax + n
        return ax
    return sum
f = lazy_sum(1, 3, 5, 7, 9)    
f()#调用函数f时，才真正计算求和
```

说明: 内部函数`sum`可以引用外部函数`lazy_sum`的参数和局部变量，当`lazy_sum`返回函数`sum`时，相关参数和变量都保存在返回的函数中，这种称为“闭包（Closure）”的程序结构拥有极大的威力。

闭包:  返回闭包时牢记一点：返回函数不要引用任何循环变量，或者后续会发生变化的变量。参考[廖雪峰博客闭包](https://www.liaoxuefeng.com/wiki/1016959663602400/1017434209254976)

### 匿名函数

关键字`lambda`表示匿名函数，冒号前面的`x`表示函数参数。

list(map(lambda x: x * x, [1, 2, 3, 4, 5, 6, 7, 8, 9]))

匿名函数`lambda x: x * x`实际上就是

```python
def f(x):
    return x * x
```

**匿名函数有个限制，就是只能有一个表达式，不用写`return`**，返回值就是该表达式的结果。

也可以把匿名函数作为返回值返回，比如：

```python
def build(x, y):
    return lambda: x * x + y * y
```

### 装饰器

在代码运行期间动态增加功能的方式，称之为“装饰器”（Decorator）

##### 两层嵌套

本质上，decorator就是一个返回函数的高阶函数。我们要定义一个能打印日志的decorator:

```python
def log(func):
    @functools.wraps(func)
    def wrapper(*args, **kw):
        print('call %s():' % func.__name__)
        return func(*args, **kw)
    return wrapper
```

> 函数对象有一个`__name__`属性，可以拿到函数的名字

借助Python的@语法，把decorator置于函数的定义处

```python
@log
def now():
    print('2015-3-25')
now()
```

调用`now()`函数，不仅会运行`now()`函数本身，还会在运行`now()`函数前打印一行日志.把`@log`放到`now()`函数的定义处，相当于执行了语句：

```
now = log(now)
```

由于`log()`是一个decorator，返回一个函数，所以，原来的`now()`函数仍然存在，只是现在同名的`now`变量指向了新的函数，于是调用`now()`将执行新函数，即在`log()`函数中返回的`wrapper()`函数。

##### 三层嵌套

如果decorator本身需要传入参数，那就需要编写一个返回decorator的高阶函数，写出来会更复杂。比如，要自定义log的文本：

```python
import functools
def log(text):
    def decorator(func):
        @functools.wraps(func)
        def wrapper(*args, **kw):
            print('%s %s():' % (text, func.__name__))
            return func(*args, **kw)
            #wrapper.__name__=func.__name__
        return wrapper
    return decorator

@log('execute')
def now():
    print('2015-3-25')    
now()
print(now.__name__)
```

和两层嵌套的decorator相比，3层嵌套的效果是这样的：

```python
now = log('execute')(now)
```

面向对象(OOP)的装饰模式需要通过继承和组合来实现，而**Python除了能支持OOP的decorator外，直接从语法层次支持decorator**。

### 偏函数

`functools.partial`就是帮助我们创建一个偏函数的.

对于一个字符串转2进制整数的函数:

```
int('12345', base=2) #每次都传入int(x, base=2)非常麻烦
int2('1000000')
#于是定义
def int2(x, base=2):
    return int(x, base)
```

使用偏函数，创建新函数

```
import functools
int2 = functools.partial(int, base=2)
int2('1000000')
```

**当函数的参数个数太多**，需要简化时，使用`functools.partial`可以创建一个新的函数，这个新函数可以固定住原函数的部分参数，从而在调用时更简单。

## 模块

#### 使用模块

```
#!/usr/bin/env python3
# -*- coding: utf-8 -*-

' a test module '

__author__ = 'Michael Liao'

import sys

def test():
    args = sys.argv
    if len(args)==1:
        print('Hello, world!')
    elif len(args)==2:
        print('Hello, %s!' % args[1])
    else:
        print('Too many arguments!')

if __name__=='__main__':
    test()
```

`sys`模块有一个`argv`变量，用list存储了命令行的所有参数。`argv`至少有一个元素，因为第一个参数永远是该.py文件的名称，例如：

运行`python3 hello.py`获得的`sys.argv`就是`['hello.py']`；

运行`python3 hello.py Michael`获得的`sys.argv`就是`['hello.py', 'Michael']`。



当我们在命令行运行`hello`模块文件时，Python解释器把一个特殊变量`__name__`置为`__main__`，而如果在其他地方导入该`hello`模块时，`if`判断将失败，因此，这种`if`测试可以让一个模块通过命令行运行时执行一些额外的代码，最常见的就是运行测试。

#### 作用域

在Python中，是通过`_`前缀来实现的。

正常的函数和变量名是公开的（public），可以被直接引用，比如：`abc`，`x123`，`PI`等；

类似`__xxx__`这样的变量是特殊变量，可以被直接引用，但是有特殊用途，比如上面的`__author__`，`__name__`就是特殊变量，`hello`模块定义的文档注释也可以用特殊变量`__doc__`访问，我们自己的变量一般不要用这种变量名；

类似`_xxx`和`__xxx`这样的函数或变量就是非公开的（private），不应该被直接引用，比如`_abc`，`__abc`等；

private函数和变量“不应该”被直接引用，而不是“不能”被直接引用，是因为Python并没有一种方法可以完全限制访问private函数或变量，但是，从编程习惯上不应该引用private函数或变量。

private函数或变量不应该被别人引用，那它们有什么用呢？请看例子：

```
def _private_1(name):
    return 'Hello, %s' % name

def _private_2(name):
    return 'Hi, %s' % name

def greeting(name):
    if len(name) > 3:
        return _private_1(name)
    else:
        return _private_2(name)
```

我们在模块里公开`greeting()`函数，而把内部逻辑用private函数隐藏起来了，这样，调用`greeting()`函数不用关心内部的private函数细节，这也是一种非常有用的代码封装和抽象的方法，即：

外部不需要引用的函数全部定义成private，只有外部需要引用的函数才定义为public。

#### 第三方模块

安装第三方模块，是通过包管理工具pip完成的

默认情况下，Python解释器会搜索当前目录、所有已安装的内置模块和第三方模块，搜索路径存放在`sys`模块的`path`变量中：

```python
import sys
sys.path
```

如果我们要添加自己的搜索目录，有两种方法：

一是直接修改`sys.path`，添加要搜索的目录：

```
import sys
sys.path.append('/Users/michael/my_py_scripts')
```

这种方法是在运行时修改，运行结束后失效。

第二种方法是设置环境变量`PYTHONPATH`，该环境变量的内容会被自动添加到模块搜索路径中。设置方式与设置Path环境变量类似。

# 参考

1. [廖雪峰 Python基础](https://www.liaoxuefeng.com/wiki/1016959663602400/1017063413904832)